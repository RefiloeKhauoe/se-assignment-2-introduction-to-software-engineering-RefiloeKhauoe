[![Review Assignment Due Date](https://classroom.github.com/assets/deadline-readme-button-24ddc0f5d75046c5622901739e7c5dd533143b0c8e959d652212380cedb1ea36.svg)](https://classroom.github.com/a/-ucQIGTc)
[![Open in Visual Studio Code](https://classroom.github.com/assets/open-in-vscode-718a45dd9cf7e7f842a935f5ebbe5719a5e09af4491e668f4dbf3b35d5cca122.svg)](https://classroom.github.com/online_ide?assignment_repo_id=15240613&assignment_repo_type=AssignmentRepo)
# SE-Assignment-2
Assignment: Introduction to Software Engineering
Instructions:
Answer the following questions based on your understanding of software engineering concepts. Provide detailed explanations and examples where appropriate.

Questions:
Define Software Engineering:
Software engineering is a discipline of computer science concerned with the design, development, testing, and maintenance of software programs. Software engineers employ engineering ideas and understanding of programming languages to create software solutions for end users. Software engineering is a larger field that spans the complete software development lifecycle, from design to implementation and maintenance. It uses engineering concepts in software development to ensure that the program is efficient, dependable, and maintainable (Sommerville, 2011).

What is software engineering, and how does it differ from traditional programming?
According to Aitken & Lango (2013) in order to determine the key differences and potential incompatibilities between these two software development paradigms, this study examines a variety of traditional and agile methodologies, approaches, and techniques. The primary differences between traditional software engineering and agile software development are discovered to be less related to iteration length or project management (as one might expect from a cursory examination) and more related to other attributes such as the variety of models used, the purpose of the models, and the approach to modeling. Finally, the two methodologies are not considered as incompatible, implying the possibility of Agile Software Engineering (ASE).Software engineering takes a comprehensive approach, addressing the complete software development life cycle (SDLC) rather than just producing code. Traditional programming emphasizes the coding part of software development (Pressman, 2010).
Process: Software engineering is structured and rigorous, frequently employing frameworks such as the SDLC. This promotes clear communication, defined stages, and risk management (Sommerville, 2011). Traditional programming may be less structured, with an emphasis on accomplishing specific coding tasks.
Teamwork: Software engineering is a collaborative effort. Software engineers work with designers, project managers, and other specialists to complete a project (Pressman, 2010). Traditional programming may involve individual developers working on smaller projects.

Software Development Life Cycle (SDLC):
The SDLC is a framework that describes a series of phases in software development. It offers a disciplined way to ensuring high-quality software that fulfills user requirements. The International Institute of Business Analysis (IIBA, 2015) defines several common phases in the SDLC as follows:

Planning and Requirements Analysis: This phase entails defining project objectives, identifying user needs, and specifying project scope.
This phase involves the design of the software architecture, system flow, and user interface.
Development (Coding): Programmers write code based on design specifications.
Testing: The program undergoes extensive testing to find and resolve bugs.
Deployment: The program is made available to users.
Maintenance involves monitoring, updating, and implementing bug fixes.




Explain the various phases of the Software Development Life Cycle. Provide a brief description of each phase.
Agile vs. Waterfall Models:
The Software Development Life Cycle (SDLC) is a framework that describes the various stages of software development (International Institute of Business Analysis, 2015). It offers a disciplined way to developing high-quality software that satisfies the needs of users. Here is a breakdown of the common phases:
Planning and Requirement Analysis: The first phase focuses on setting project goals, identifying user needs through interviews, surveys, or user stories, and outlining the overall project scope (Pressman, 2010).

This phase involves designing the software architecture, system flow, and user interface based on the requirements that have been acquired. To visualize the software's functionality, use wireframes, mockups, or flowcharts (Sommerville, 2011).

Development (Coding): Using a clear design blueprint, programmers build code that adheres to the design parameters. This phase entails creating functionality, integrating various components, and conforming to coding standards (Pressman, 2010).

Testing: The program is rigorously tested to discover and resolve bugs. To guarantee that the program works as intended, many testing approaches are used, including unit testing, integration testing, and user acceptability testing (UAT) (Sommerville, 2011).
Deployment: After testing and determining that the program is working, it is deployed to the target environment and made available to users. This could include distributing the software to an app store, deploying it on a server, or providing users with access credentials (Pressman, 2010).

Maintenance: Software development is iterative. Even after deployment, the program is being monitored for bugs, performance concerns, and security flaws. This phase entails addressing bugs, delivering updates, and adapting the software to changing user requirements. Somerville (2011).
Agile versus Waterfall Models
There are two main SDLC models: Agile and Waterfall. They have significantly different approaches to software development:

Waterfall paradigm (Pressman, 2010): This classic, sequential paradigm progresses in a linear manner through each SDLC phase. Requirements are acquired first, and development proceeds in a step-by-step fashion, with each stage fulfilled before going on to the next. This strategy is ideal for projects with well-defined needs and modest change expectations.

Agile Model (Sommerville, 2011) This iterative and incremental technique focuses on delivering working software in short cycles (sprints) while providing ongoing feedback and adaption. Requirements might change throughout the development process, providing more adaptability to changing needs. Agile approaches, such as Scrum, emphasize cooperation and continual improvement, making them appropriate for projects with evolving requirements or a high degree of uncertainty.

Choosing the right SDLC model depends on the specific project characteristics and team preferences.
Agile versus Waterfall. Models for Software Development
Software development projects can be managed using a variety of strategies, including Agile and Waterfall. These models take fundamentally distinct approaches to project structure and flexibility (Sommerville, 2011).

Agile methodology.

Iterative development is the primary focus: software is produced and delivered in short cycles (sprints), with constant feedback and adaption. This enables for flexibility in needs, which might grow over the project.
Agile teams value close collaboration among developers, designers, and stakeholders (Sommerville, 2011). This creates a dynamic ecosystem in which users' demands are constantly addressed.
Prioritizes working software over comprehensive documentation: While documentation is still vital, Agile prioritizes providing functional software fast rather than creating substantial upfront documentation (Sommerville, 2011).
Waterfall Model

Follows a linear, sequential approach: requirements are acquired first, and development proceeds step by step, with each SDLC phase (planning, design, development, testing, deployment, and maintenance) accomplished before moving on to the next (Pressman, 2010).
Suitable for clearly specified requirements: This structured method is effective when project requirements are clear and unlikely to alter considerably throughout development (Pressman, 2010).
establishes explicit project milestones: The Waterfall methodology, with its specified sequence, provides unambiguous project milestones and a predictable timetable (Pressman 2010).

				
		


Compare and contrast the Agile and Waterfall models of software development. What are the key differences, and in what scenarios might each be preferred?
Requirements Engineering:
The key differences between Agile and Waterfall models: Feature	Agile	Waterfall
Development Approach	Iterative and incremental	Sequential
Requirement Flexibility	High	Low (requirements gathered upfront)
Team Collaboration	Highly emphasized	Less emphasized
Documentation	Less prioritized initially	More comprehensive upfront documentation. 
Choosing the Right Model.

The best SDLC model depends on the project's individual features:

Agile is best suited for projects with changing needs, high uncertainty, or the need for quick feature delivery. It's also ideal for tasks that require tight collaboration and continuous input.
Waterfall is best suited for projects with well-defined requirements, a stable development environment, and the necessity for specific project milestones and timetables. It may also be appropriate for projects that have stringent regulatory compliance requirements.
Requirements Engineering

Before entering into Agile or Waterfall development, Requirements Engineering (RE) is an essential stage (Pressman 2010). RE entails gathering, evaluating, specifying, validating, and maintaining stakeholder requirements for the software system (Pressman, 2010). This technique ensures a clear knowledge of what the program needs to accomplish, which is critical for both Agile and Waterfall methodologies




What is requirements engineering? Describe the process and its importance in the software development lifecycle.
Software Design Principles:
Requirements Engineering (RE) is an important element in the Software Development Life Cycle (SDLC) that involves obtaining, assessing, documenting, and monitoring stakeholder demands for the software system (Pressman, 2010). It primarily serves as a link between the problem domain (real-world requirements) and the solution domain (software development). Here's an explanation of the RE process and its significance:
RE Process:

Elicitation: This is the first stage in which needs are gathered from multiple stakeholders, including users, clients, domain experts, and project managers. Interviews, surveys, workshops, and user stories are all useful techniques for identifying needs and features (Pressman, 2010).

Analysis: The requirements are reviewed for completeness, consistency, feasibility, and prioritizing. Conflicts or misunderstandings are detected and handled to ensure that everyone understands what the software needs to do (Sommerville, 2011).
Specification: Clear and succinct documentation that outline the software's functionalities, features, and behaviors are generated. These standards serve as a guideline for the development team (Pressman 2010).

Validation: Stakeholders assess the documented requirements to ensure that they appropriately represent their needs. This iterative procedure assists in identifying and correcting any misunderstandings (Sommerville, 2011).
Importance of RE:

RE promotes a clear knowledge of what the software must perform, resulting in a more focused development process and a higher-quality product (Pressman, 2010).
Reduced Errors: Recognizing and fixing ambiguities early on helps to reduce errors and rework later in the development cycle (Sommerville, 2011).
RE improves communication among stakeholders by establishing a common basis for discussing and documenting demands (Pressman, 2010).
Reduced Development Costs: Early issue detection and accurate requirements specification can result in lower development costs and project delays (Sommerville 2011).
Increased Project Success: A well-defined set of criteria improves overall project success by guaranteeing that the program matches user needs (Pressman, 2010).


Explain the concept of modularity in software design. How does it improve maintainability and scalability of software systems?
Testing in Software Engineering:
Modularity is a key component of excellent software design. It emphasizes the significance of breaking down a software system into smaller, well-defined, and autonomous pieces known as modules (Sommerville, 2011). These modules are intended to conduct certain activities and communicate with one another via clearly defined interfaces.Here's how a modularity approach improves software development:

Improved Maintainability: Modular systems are easier to maintain and debug (Pressman 2010). If a flaw occurs, developers can concentrate on the exact module where the problem exists, decreasing the time and effort required to resolve it. Changes or modifications to a module can also be made with minimum influence on other elements of the system, which promotes long-term maintainability.

Modular systems have higher scalability (Pressman, 2010). As functionalities or user needs change, new modules can be readily added or current modules adjusted without affecting the overall system structure. This enables the software to adapt and grow efficiently.

Encourages Reusability: Well-designed modules can be reused in different areas of the same software or even across multiple projects (Pressman, 2010). This minimizes development time and effort by utilizing previously tested code blocks.
Modular systems have higher scalability (Pressman, 2010). As functionalities or user needs change, new modules can be readily added or current modules adjusted without affecting the overall system structure. This enables the software to adapt and grow efficiently.
Here are some important features of well-defined modules:

A module should have strong cohesiveness, which means it concentrates on a single, well-defined function. This encourages improved code organization and understanding.
Modules should have low coupling, which means they communicate with each other with few dependencies (Sommerville, 2011). This reduces the impact of changes in one module on the rest of the system.
Clear Interfaces: Each module should have a clear and well-defined interface that explains how other software components can communicate with it. This encourages loose coupling and facilitates communication between components.


Describe the different levels of software testing (unit testing, integration testing, system testing, acceptance testing). Why is testing crucial in software development?
Version Control Systems:
Testing in Software Engineering
Pressman (2010) testing, which follows the design phase, is an important element in the SDLC. Testing entails ensuring that the software satisfies its intended functionality and performance specifications. Here's why testing is important:

Bug Detection and Prevention: Testing helps to find and solve issues in software before it is released to users. This lowers the likelihood of software faults and results in a more reliable product (Pressman, 2010).
Quality assurance: Through rigorous testing, engineers may guarantee that the program satisfies quality standards and user expectations. This encompasses things like functionality, performance, usability, and security (Pressman 2010).
Early Problem Identification: Testing enables the early detection of problems, saving time and costs compared to correcting issues after distribution.
Improved User Experience: Testing helps to ensure that software works as intended and is user-friendly (Pressman, 2010).
here are different testing approaches used throughout the development lifecycle, such as:
Unit testing involves testing individual units or modules of code in isolation.
Integration Testing: Modules are tested together to verify they work properly.
System testing involves testing the entire software system to ensure that it functions properly and performs well.
Acceptance testing is conducted by users or stakeholders to ensure that the software satisfies their requirements.
Effective testing techniques are critical for developing high-quality, dependable, and user-friendly software systems.
Levels of Software Testing
Software development entails a thorough testing process to verify that the end result is of high quality and functional. This procedure is often separated into multiple tiers, each with its own focus (Pressman, 2010):
Unit testing is the most granular level, concentrating on the smallest building parts of software, such as individual units or code modules. Developers conduct unit tests to ensure that each unit functions properly in isolation from the rest of the system (Sommerville, 2011). This aids in detecting flaws early in the development process, making them easier to resolve.
Integration Testing: After individual pieces are tested, they are combined and tested together. The goal of integration testing is to ensure that diverse modules interact and work as a cohesive whole. This level reveals concerns with communication and data sharing across different elements of the system (Pressman, 2010)

System Testing: This level evaluates the entire software system as a whole. System testing compares the system's functionality, performance, security, and usability to its overall requirements (Pressman, 2010). It guarantees that the entire system serves its intended function and operates as planned.

Acceptance Testing: In the last step, users or stakeholders test the product to see if it meets their requirements and expectations (Sommerville, 2011). This critical stage helps to ensure that the program is user-friendly and valuable.
Importance of Testing in Software Development
Testing is an important element of software development for a variety of reasons.

Bug Detection and Prevention: Testing assists in identifying and resolving flaws before the product is released to users. This lowers the likelihood of software faults and results in a more reliable product (Pressman, 2010).
Improved Quality and Performance: By rigorously testing the program, developers can verify that it satisfies quality requirements and operates efficiently. This encompasses features such as functionality, speed, reactivity, and resource utilization (Pressman 2010).
Early Problem Identification: Testing enables early detection of problems, saving time and costs compared to correcting issues after deployment (Sommerville, 2011). Bugs uncovered during testing are typically easier and less expensive to fix than those discovered later in the development lifecycle.
Enhanced User Experience: Testing helps to ensure that software works as intended and is user-friendly. Users are more likely to embrace and continue using software that is simple to use, dependable, and fits their requirements.
Successful software development relies heavily on effective testing procedures. Developers may create high-quality, dependable, and user-friendly software systems by implementing various testing levels throughout the development process (Pressman, 2010).


What are version control systems, and why are they important in software development? Give examples of popular version control systems and their features.
Software Project Management:
Version Control Systems
Once you've written and tested your code, maintaining different versions becomes crucial. This is where Version Control Systems (VCS) come in (https://en.wikipedia.org/wiki/Version_control_system). A VCS tracks changes to your code over time, allowing you to revert to previous versions if needed, collaborate with other developers, and manage different branches of your codebase.
Version Control System (VCS)
Sommerville (2011) is of the opinion that Version Control Systems (VCS) are important in software development because they manage and track changes to code over time. They serve as a historical record of your project's progress, allowing developers to:

Track Changes: VCS painstakingly records every modification to the codebase. This enables developers to see who made modifications, when they occurred, and what the particular changes were.

Revert to Previous Versions: If necessary, developers can simply return the codebase to a previous state, which is useful for troubleshooting or recovering from inadvertent modifications (Pressman, 2010).

Collaboration: VCS allows developers working on the same project to work together more easily. Multiple developers can work on different portions of the codebase at the same time, seamlessly merging their modifications.

Branching: VCS allows developers to build branches, which are effectively clones of the code base. This enables testing with new features or problem fixes without affecting the main codebase (Sommerville, 2011). Once the changes have been completed and tested, branches can be merged back into the main codebase.
Popular VCS options and their features:
Here are some popular VCS options and their key features:
•	Git: An industry-standard, distributed VCS known for its flexibility, branching capabilities, and offline functionality ( https://www.git-scm.com/). Git allows developers to have a complete copy of the repository on their local machines, enabling them to work even without an internet connection.
•	Subversion (SVN): A centralized VCS offering a simpler user interface and easier branching compared to Git ( https://subversion.apache.org/). However, SVN lacks some of the advanced features and flexibility of Git.
•	Mercurial: Another distributed VCS similar to Git, but with a slightly different workflow ( https://mercurial-scm.org/). Mercurial offers good branching capabilities and is known for its ease of use.
Importance of VCS in Software Project Management
VCS are essential tools for effective software project management (Pressman, 2010). They provide:
•	Improved Collaboration: By facilitating teamwork and code sharing, VCS streamline the development process, especially for geographically dispersed teams.
•	Enhanced Project Visibility: VCS offer a clear overview of the project's history, allowing project managers to track progress, identify areas requiring attention, and make informed decisions.
•	Reduced Risk of Errors: The ability to revert to previous versions and manage branches helps mitigate the risk of errors and makes it easier to recover from mistakes.
•	Efficient Codebase Management: VCS enable developers to organize and manage the codebase effectively, ensuring a clean and maintainable codebase over time.By adopting a VCS, software development teams can streamline workflows, improve collaboration, and deliver high-quality software projects more efficiently.



Discuss the role of a software project manager. What are some key responsibilities and challenges faced in managing software projects?
Software Maintenance:
The Software Project Manager: Maestro of the Development Symphony.
A software project manager leads and coordinates the development process to create software that satisfies specified criteria while staying within budget and time limitations (Lientz, Bethke, Sinclair, & Dean, 2009). They wear multiple hats, supervising numerous areas of the project lifecycle.

Key responsibilities:

The project manager specifies the project scope and develops a detailed project plan that includes schedules, milestones, and resource allocation (Lientz et al., 2009). They also divide the project into manageable parts and ensure that it is on track to achieve its objectives.
Team Leadership and Resource Management: Effective project managers motivate and lead their teams, distribute tasks, and manage resources (people and equipment) efficiently (Lientz et al., 2009). This includes fostering a collaborative environment, resolving conflicts, and ensuring team members have the necessary skills and tools to complete their tasks.

Risk management: Software projects are inherently dangerous. The project manager proactively identifies potential risks, creates mitigation solutions, and monitors the project for potential problems (Lientz et al. 2009).
Communication and stakeholder management: Clear communication is essential. The project manager serves as a liaison between developers, clients, stakeholders, and other project members, ensuring that everyone is informed and aligned with project objectives (Lientz et al. 2009). This includes providing regular progress reports, status updates, and managing stakeholder expectations.
Quality Assurance: While not completely accountable for quality, the project manager is critical to ensuring that the software produced fulfills quality standards (Lientz et al. 2009). This may include collaborating with the testing team and ensuring that suitable testing processes are followed.
Challenges in Software Project Management:

Despite rigorous planning, software initiatives might face a variety of challenges:

Scope Creep: Unexpected changes in requirements or project scope can derail timelines and budgets (Lientz et al., 2009). Project managers must manage stakeholder expectations and properly communicate the implications of scope changes.
Resource constraints: Limited resources (people, budget, and time) might present difficulties. Project managers must optimize resource allocation and prioritize tasks to ensure that project objectives are completed within restrictions.
Communication Issues: Miscommunication among team members, stakeholders, and clients can cause confusion and delays (Lientz et al., 2009). Project managers must develop clear communication channels and actively listen to diverse viewpoints.
Emerging technology and unforeseen technological challenges can disrupt the development process (Lientz et al., 2009). Project managers must be adaptive and eager to learn and change plans as necessary.
By efficiently tackling these problems and leveraging their wide skill set, software project managers contribute significantly to the success of software development projects.



Define software maintenance and explain the different types of maintenance activities. Why is maintenance an essential part of the software lifecycle?
Ethical Considerations in Software Engineering:
Software Maintenance: Keeping the Software Song Going.
Once software is deployed, its journey does not end. Software maintenance includes the operations required to maintain the software running properly after it has been launched (Lientz et al., 2009). This includes:

Bug fixes include addressing flaws and mistakes found by users or during post-release testing.
Performance enhancements include optimizing the software for increased speed, responsiveness, and resource use.
New Feature Development: Adding new features based on user feedback or changing business requirements.
Adapting to Change: Keeping software compatible with evolving technologies and operating systems (Lientz et al., 2009).
Effective software maintenance is critical for ensuring that the product stays useful to users and meets their needs over time.

Software Maintenance: Keeping the Software Ship Afloat.
Software development is a continuous process rather than an isolated event. After deployment, a software product enters the software maintenance phase (Pressman, 2010). This includes all of the activities required to ensure that the software continues to function properly after its release. Just like a ship requires continual maintenance to properly navigate the seas, software need frequent upkeep to ensure it remains 
There are four main categories of software maintenance activities:

Corrective Maintenance is the process of discovering and correcting faults or problems reported by users or identified during post-release testing (Pressman, 2010). Corrective maintenance is critical for ensuring that the program works as intended and delivers a consistent user experience.
Adaptive Maintenance: The program must respond to changes in its environment (Pressman, 2010). This could include changes to make the software compatible with new operating systems, hardware, or third-party applications. Furthermore, changes in rules or business requirements may compel modifications to the software's functionality.

Perfective maintenance aims to improve the software's functionality, performance, or usability (Pressman, 2010). It could include adding new features based on customer feedback, increasing the software's speed and responsiveness, or upgrading the user interface for ease of use.

Preventive Maintenance: Proactive maintenance efforts seek to identify and address possible problems before they occur (Pressman 2010). This could include code reworking to increase maintainability, performance optimization to avoid future slowdowns, or examining code for potential vulnerability.
Why is maintenance necessary?
Software maintenance is an essential element of the software lifecycle for a number of reasons:

Ensured Functionality and Reliability: Regular maintenance helps to correct issues, enhance performance, and keep the software running properly. This ensures that users receive a reliable and trustworthy product.
Adaptability and evolution: The software landscape and user requirements are always changing. Maintenance enables software to adapt to these changes, ensuring its relevance and value over time.
Reduced Costs: Proactive maintenance, such as preventive maintenance, can help to avoid costly difficulties later in the software's lifecycle (Pressman, 2010). Fixing minor faults early on is frequently less expensive than dealing with larger difficulties later.
Maintenance actions can boost user satisfaction by responding to feedback and making adjustments.
Ethical Considerations for Software Engineering
When undertaking software maintenance, ethical considerations take priority (Gottesdiener, 2003). Here are some crucial points to consider:

Transparency: Users should be informed of maintenance efforts, any downtime, and any software updates.
Security updates: Keeping software secure is critical. Developers are responsible for swiftly addressing security vulnerabilities (Gottesdiener, 2003).
Data Privacy: User data privacy must be maintained throughout the maintenance process. Developers should follow data privacy legislation and user agreements.
By focusing on these areas and adhering to ethical norms, software engineers can ensure that maintenance efforts contribute to a positive and responsible development lifecycle.





What are some ethical issues that software engineers might face? How can software engineers ensure they adhere to ethical standards in their work?
Ethical Issues in Software Engineering
Software engineers shape the technical landscape with which we engage on a daily basis. However, this power entails a responsibility to evaluate the ethical implications of their activity. Here are some common ethical challenges software developers may face:

Privacy Concerns: Software frequently collects and handles user data. Engineers must make ethical decisions about what data is acquired, how it is stored, used, and safeguarded. Balancing functionality and user privacy is an important concern (Gottesdiener, 2003).
Algorithmic Bias: Software is increasingly relying on algorithms to make decisions. However, algorithms can inherit and exaggerate biases in the data on which they are taught. Engineers must be mindful of potential biases and seek to design fair, unbiased algorithms. (Johnson, 2019).

Security Vulnerabilities: Software vulnerabilities can be exploited for nefarious reasons, endangering user data and systems. Engineers must build secure code, swiftly repair vulnerabilities, and emphasize user safety (Gottesdiener, 2003).

Intellectual Property Rights: Software engineers must be aware of copyright and intellectual property regulations. Copying coding or exploiting copyrighted content without authorization poses ethical considerations (Johnson, 2019).

Automation and employment Displacement: The automation of tasks using software might result in employment displacement. While automation is beneficial, engineers should consider the potential negative impacts and advocate for responsible implementation (Gottesdiener, 2003).
Maintaining ethical standards.
The following practices can help software engineers adhere to ethical standards:

Understanding Ethical Codes: Become acquainted with professional codes of ethics for software engineers, such as those established by the ACM or IEEE (Gottesdiener, 2003). These codes establish guidelines for ethical decision-making.
Questioning and raising concerns: Do not be hesitant to challenge methods or designs that pose ethical concerns. Share your concerns and advocate for ethical development practices in your team or company.
Transparency and User Trust: Maintain transparency about how software collects and uses data. Inform users of potential risks and give them control over their data wherever possible Prioritizing User Safety and Security: Security flaws should be rectified immediately. Engineers have the responsibility to write secure programming.




REFERENCE LIST


Aitken, A. and Ilango, V., 2013, January. A comparative analysis of traditional software engineering and agile software development. In 2013 46th Hawaii International Conference on System Sciences (pp. 4751-4760). IEEE.

Gottesdiener, E. (2003). Professional ethics and code of conduct for software engineers. ACM/IEEE-CS Joint Task Force on Software Engineering Ethics.

https://en.wikipedia.org/wiki/Version_control_system 

 https://www.git-scm.com/

 https://subversion.apache.org/

 https://mercurial-scm.org/

International Institute of Business Analysis (IIBA). (2015). A Guide to the Business Analysis Body of Knowledge (BABOK Guide), Version 3.2

Johnson, David E. (2019). Computer Ethics. Pearson Education Limited.
Lientz, B. P., Bethke, E., Sinclair, S., & Dean, J. (2009). Object-Oriented Software Development (8th ed.). McGraw-Hill.

Pressman, Roger S. (2010). Software Engineering: A Practitioner's Approach. McGraw-Hill 

Sommerville, I. (2011). Software Engineering. Addison-Wesley


